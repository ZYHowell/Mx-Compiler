//it is not actually real codes, since I implement these rules during visiting AST 
if decl(e): 
e::= t x = s; 
init(x, e)
if succ(e', e) && scope(e) == scope(e'): 
    //achieve this by a stack rather than a real "if"
    def(x, e'), type(x, t)

Check CE by: 
init(x, e) && !live(x, e) 
///this live is different from that before regAlloc, but the logic is the same
init(x, e) && !def(x, e)
live(x, e) && !def(x, e)

Type checking: 
implicit conversions: 
e::= e1 + e2: 
    typeTmp = LCA(e1.type, e2.type);
    assert(e.type >= typeTmp);
    typeTmp a1, a2; 
    a1 = (typeTmp)(e1.value);
    a2 = (typeTmp)(e2.value);
    e.value = (e.type)(a1 + a2);
polymorphism: 
e::= f(e1, e2) && f::=(type_i_1, type_i_2) to type_i_dest, i=1,2...n
//use the type expression. not this time